<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.28
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="linedb-the-partitioned-array-managed-partitioned-array-and-file-context-managed-partitioned-arraymanager-and-the-partitioned-array-database-fundamental-data-structures-and-array-of-hashes-database-system">LineDB, The Partitioned Array, Managed Partitioned Array and File Context Managed Partitioned Array/Manager, and the Partitioned Array Database: Fundamental Data Structures and Array-Of-Hashes Database System</h1>

<ul>
  <li><strong>YARD Documentation</strong>: https://midscore.io/partitioned_array_library/doc/index.html (Last Updated: 1/13/2023)</li>
  <li><strong>Source Code</strong>: https://github.com/ZeroPivot/partitioned_array/tree/master/lib</li>
  <li><strong>GitHub README</strong>: https://github.com/ZeroPivot/partitioned_array#readme</li>
</ul>

<h2 id="update---1252023---linedbpartitioned-array-library-writeup">Update - 1/25/2023 - LineDB/Partitioned Array Library Writeup</h2>
<p>https://github.com/ZeroPivot/partitioned_array/tree/master/LineDB</p>

<h2 id="update-1122023-500am---linedb">Update 1/12/2023 (5:00AM) - LineDB</h2>

<h3 id="linedb-database-class-for-the-partitioned-array-database">LineDB database class for the Partitioned Array Database</h3>

<p>Location: <code>lib/line_db.rb</code></p>

<h4 id="linedb-setup">LineDB Setup</h4>

<p>Works in tandem with <code>lib/line_database_setup.rb</code>; the setup file creates the database text file and LineDB loads those files into a hash object that points to each Partitioned Array Database, which LineDB uses.</p>

<h2 id="update-1132023-228am---the-line-reader-and-line-database">Update 1/13/2023 (2:28AM) - the line reader and line database</h2>

<h3 id="line-database-line-reader-line-database-setup">Line Database, Line Reader, Line Database Setup</h3>

<p>Created a set of helper functions to maintain a hash array set of Partitioned Array Databases:
<code>lib/line_reader.rb</code></p>

<p>Helper functions to deal with line_database
<code>lib/line_database_setup.rb</code></p>

<p>Setup the PartitionedArrayManager databases; specify the database names you want, which is written to a file.
<code>lib/line_database.rb</code></p>

<p><code>load_pad</code> helper function will load db_list.txt into a hash with those names referring to the PAM database objects</p>

<h2 id="update-1122023-1023pm---the-partitioned-array-database">Update 1/12/2023 (10:23PM) - The Partitioned Array Database</h2>

<p>In – https://github.com/ZeroPivot/partitioned_array/tree/master/lib:</p>

<ul>
  <li><strong>Partitioned Array Database</strong>: https://github.com/ZeroPivot/partitioned_array/blob/master/lib/partitioned_array_database.rb</li>
  <li><strong>FileContextManagedPartitionedArrayManager</strong>: https://github.com/ZeroPivot/partitioned_array/blob/master/lib/file_context_managed_partitioned_array_manager.rb</li>
  <li><strong>FileContextManagedPartitionedArray</strong>: https://github.com/ZeroPivot/partitioned_array/blob/master/lib/file_context_managed_partitioned_array.rb</li>
  <li><strong>ManagedPartitionedArray</strong>: https://github.com/ZeroPivot/partitioned_array/blob/master/lib/managed_partitioned_array.rb</li>
  <li><strong>PartitionedArray</strong>: https://github.com/ZeroPivot/partitioned_array/blob/master/lib/partitioned_array.rb</li>
</ul>

<p>All in https://github.com/ZeroPivot/partitioned_array/tree/master/lib</p>

<h2 id="synopsis">Synopsis</h2>

<h3 id="partitioned-array-database--managed-partitioned-array--file-context-managed-partitioned-array-manager">Partitioned Array [Database] | Managed Partitioned Array / File Context Managed Partitioned Array [Manager]</h3>

<p>Partitioned Array Library Repo: https://github.com/ZeroPivot/partitioned_array</p>

<ul>
  <li>README: https://github.com/ZeroPivot/partitioned_array#readme</li>
  <li>YARD Documentation: https://midscore.io/partitioned_array_library/doc/index.html</li>
</ul>

<h3 id="usage">Usage</h3>

<ul>
  <li>Installation</li>
</ul>

<p><code>git clone https://github.com/ZeroPivot/partitioned_array.git</code></p>

<ul>
  <li>In Ruby:</li>
</ul>

<p><code>require 'lib/file_context_managed_partitioned_array_manager'</code></p>

<p>or</p>

<p><code>require 'lib/partitioned_array_database</code></p>

<ul>
  <li>Data structures available:</li>
</ul>

<p><code>ruby
LineDB
PartitionedArrayDatabase
FileContextManagedPartitionedArrayManager
FileContextManagedPartitionedArray
ManagedPartitionedArray
PartitionedArray
</code></p>

<ul>
  <li>Helper Functions</li>
</ul>

<p><code>ruby
pad_hash_database = load_pad # lib/line_database.rb
</code></p>

<ul>
  <li>“Inheritance Tree”</li>
</ul>

<p><code>PartitionedArrayDatabase.FileContextManagedPartitonedArrayManager.FileContextManagedPartitionedArray.(ManagedPartitionedArray &lt; PartitionedArray)</code></p>

<ul>
  <li>Example:</li>
</ul>

<p>```ruby
a = FileContextManagedPartitionedArrayManager.new</p>

<p>…</p>

<p>a.database_table(“database”, “table”).get(0) # Resembles the “inheritance” tree in terms of object calls, and ManagedPartitionedArray &lt; PartitionedArray implies that ManagedPartitionedArray inherits from PartitionedArray, and MPA &lt; PA is being called with get(0)
```</p>

<h2 id="updates">Updates</h2>

<ul>
  <li>January 10, 2023
    <ul>
      <li>FileContextManagedPartitionedArray (v1.0.5 release) and FileContextManagedPartitionedArrayManager (v2.0.5 release) reached a stable state, and are ready for use and battle testing</li>
      <li>Advice: Use the FileContextManagedPartitionedArrayManager class; it is the most high level and features a NoSQL database-like interface</li>
      <li><code>YARD Documentation</code> is more comprehensive (https://midscore.io/partitioned_array_library/doc/index.html)</li>
    </ul>
  </li>
  <li>
    <p>January 3, 2023 (1/3/2023) - 1:00PM - Added FileContextManagedPartitionedArrayManager info on implementation at the end of README.md; this is the final product for the partitioned array, and turns it into a database</p>
  </li>
  <li>TODO: Add documentation on the FileContextManagedPartitionedArrayManager class, and the FileContextManagedPartitionedArray class, like a quick tutorial</li>
</ul>

<h2 id="quick-compatibility-list"><strong>Quick Compatibility List</strong></h2>

<ul>
  <li>
    <p><strong>Ruby 3.0-3.2+</strong>: (<code>/lib/partitioned_array</code>) - <em>lib/managed_partitioned_array.rb</em> - <strong>Fully Compatible</strong></p>
  </li>
  <li>
    <p><strong>jruby</strong>: (<code>same as ruby 3.0 version</code>)  - <em>lib/managed_partitioned_array.rb</em> - <strong>Fully Compatible</strong></p>
  </li>
  <li>
    <p><strong>DragonRuby</strong>: (<code>/lib/dr_partitioned_array</code>) - <em>dr_managed_partitioned_array.rb</em> - <strong>Fully Compatible</strong> – not synchronized with FileContextManagedPartitionedArray(Manager) yet (1/20/2023 - 4:45AM)</p>
  </li>
  <li>
    <p><strong>Python</strong>: <em>./managed_partitioned_array_python</em> folder - <strong>(WIP)</strong></p>
  </li>
  <li>
    <p><strong>NOTE</strong>: File Context Managed Partitioned Array/Manager (lib/file_context_managed_partitioned_array.rb / lib/file_context_managed_partitioned_array_manager.rb [“FCMPA/FCMPAM”]) are in the same <code>lib</code> folder; documentation at the bottom</p>
  </li>
</ul>

<h2 id="initial-notes">Initial Notes</h2>

<p>(There is much less need for the basis partitioned_array.rb, as managed_partitioned_array.rb does everything, and more.)</p>

<p>Note: Managed partitioned array info is near the bottom of this README.md file, and will be updated accordingly; just need to get a bearing on how im going to write this documentation (Last updated: 10/19/2022 12:11PM)</p>

<p>See: CHANGELOG.md for a list of changes</p>

<h2 id="update-11182022">Update 11/18/2022</h2>

<ul>
  <li>Added FileContextManagedPartitionedArray info on implementation at the end of README.md</li>
  <li>Information on HTTP/HTTPS implementation of a <code>FCMPA</code> in <code>HTTPS_FCMPA_README.md</code></li>
</ul>

<h2 id="update-9252021">Update 9/25/2021</h2>

<p>In case one’s wondering, the additional layer of abstraction is called a ManagedPartitionedArray, which keeps a track of the array index and inherits from PartitionedArray. When I go to work today 2-4 hours from now I’m going to work on the ManagedPartitionedArray Documentation. -ArityWolf</p>

<h2 id="wip-notes-last-updated-9142022">WIP NOTES (Last Updated: 9/14/2022)</h2>

<p>In recent developments, this only describes the low-level ish nature of a PartitionedArray data structure, and even that is still incomplete.</p>

<p>In the lib folder, I have completed the (inherited from PartitonedArray) ManagedPartitionedArray class which describes how to treat a PartitionedArray closer to an array with bounds set to it, and that is what the main focus of the rest of this documentation will be about. In the end, everything about the data structure will be described in full detail.</p>

<p>You can think of a partitioned array in general as an array that has disk I/O and saves the data in .json, but it could be extended to deal with whatever you throw at it</p>

<p>It will also be fully compatible with the DragonRuby game development toolkit albeit with a few minor caveats, and several details that need to be addressed in some way</p>

<h3 id="later-goals">Later Goals</h3>

<ul>
  <li>
    <p>Documentation on all code on this page, leaving nothing out</p>
  </li>
  <li>Prettify the code, and make as efficient as possible</li>
  <li>Lower level language implementation(s)</li>
  <li>DragonRuby file I/O implementation, aimed at both Linux/Windows</li>
</ul>

<hr />

<h3 id="everything-below-this-line-needs-to-be-updated">Everything below this line needs to be updated</h3>

<p>(But it does document the PartitionedArray class alright thus far)</p>

<ul>
  <li>Upcoming additions: ManagedPartitonedArray documentation, and cleaned up PartitionedArray documentation</li>
</ul>

<h2 id="synopsis-1">Synopsis</h2>

<p>A partitioned array is defined as a datastructure which has “partitioned elements” within what should be a <code>regular array</code></p>

<p>The data structure used for every element in the array is a Ruby Hash, or otherwise known as an Associative Array</p>

<p>Example of how a <code>partitioned array</code> is structured:</p>

<p><code>figure 69 (partitioned array structure):</code>
<code>[[0, 1, 2], [3, 4], ..., [n, ..., n+1]]</code></p>

<p><code>Caveat</code>: The first partition (<code>[0,1,2]</code> always contains the 0th element otherwise known as <code>0</code> )</p>

<p>However, as a note: The partitioned array algorithm is currently coded in a way that it does not actually use subarrays; the algorithm takes responsibility for all aspects of the data structure (partitions, ranges, etc), so an array when defined by <code>fig 69</code>, would look slightly different, it would look like…</p>

<p><code>[0, 1, 2, 3, 4, n, n+1, n+2, ..., n+k]</code></p>

<p>Note: The basic idea is you can store the array itself onto disk and “switch off” certain partitions, thus allowing for Ruby’s Garbage collector to take hold</p>

<p>```ruby
require_relative ‘partitioned_array’</p>

<p>pa = PartitionedArray.new
pa.allocate</p>

<p>pa.add do |hash|
    hash[‘value’] = “value”
end</p>

<p>pa.get(id) # =&gt; “Get an element of the partitioned array, using binary search”</p>

<p>pa.delete_partition_subelement(id, partition_id)
pa.delete(id)
pa.set_partition_subelement(id, partition_id, &amp;block)
pa.delete_partition(partition_id)
pa.get_partition(partition_id)
pa.set(id, &amp;block)
pa.add_partition</p>

<p>pa.add_partition #=&gt; “dynamically allocates new partition sub-elements to the partitioned array, as defined by the constants”</p>

<p>pa.load_from_files! #=&gt; loads database from json files, using Ruby’s JSON parser
pa.load_partition_from_file!(partiion_id) #=&gt; loads a given partition id from the @data_arr array
pa.save_partition_to_file!
pa.save_all_to_files!</p>

<p>pa.dump_to_json!</p>

<p>=begin
The above is basic usage for the partitioned array data structure. For tested code and configuration options, see below.
=end
```</p>

<p><strong>WIP.</strong> - <strong><em>Last updated: 4.27.2022</em></strong></p>

<p>A partitioned array data structure which works with JSON for disk storage, and a pure JSON parser is in progress. With two constants, the algorithm creates a data structure and allocates empty associative array elements and understands the structure of the partitions.</p>

<p>The main purpose was I needed a way to divide an array into subelements, so that in gamedev I can flip on and off portions of the array in question to save on memory.</p>

<p>The data structure overall is an <code>Array-Of-Hashes</code>.</p>

<h2 id="usage-1">Usage</h2>

<h3 id="assumed-constants">Assumed Constants</h3>

<p><code>ruby
# DB_SIZE &gt; PARTITION_AMOUNT
PARTITION_AMOUNT = 5 # Number of subelements per partition. CAVEAT: the first partition quantity is always PARTITION_AMOUNT + 1
DB_SIZE = 3 # The DB_SIZE is the total # of partitions within the array; starts at 0
OFFSET = 1 # This came with the math
PURE_RUBY = false # WIP
DB_NAME = 'partitioned_array_slice'
DEFAULT_PATH = './CGMFS'
DEBUGGING = false
</code></p>

<h3 id="examples">Examples</h3>

<p><code>main_refined.rb, visuals.rb</code></p>

<p>Visualization of the partitions within <code>@data_arr</code></p>

<p><code>visuals.rb</code></p>

<p><code>ruby
# Visuals; Show the basic data structure, by filling with entries, where each id is a part of that respective array partition
def allocate_ranges_sequentially(partitioned_array)
  range_arr = partitioned_array.range_arr
  range_arr.each_with_index do |range, range_index|
    range.to_a.each_with_index do |range_element, range_element_index|
      partitioned_array.set_partition_subelement(range_element_index, range_index) do |partition_subelement|
        partition_subelement["id"] = range_index
      end
    end
  end
  partitioned_array.data_arr
end
</code></p>

<p><code>main_refined.rb</code></p>

<p>```ruby
require_relative ‘partitioned_array’
require_relative ‘visuals’</p>

<h1 id="create-a-new-data-structure-and-allocate-the-partition-to-memory">Create a new data structure and allocate the partition to memory</h1>
<p>partitioned_array = PartitionedArray.new
partitioned_array.allocate</p>

<h1 id="returns-the-partition-elements-within-the-first-partition-within-dataarr-returns-a-hash-of-relevant-data-if-argument-is-true-optional">Returns the partition elements within the first partition within @data_arr; returns a hash of relevant data if argument is true (optional)</h1>
<p># Examples
id = 0
p “First Partition in @data_arr: #hash: false)” # get a partition (a chunk) of a partition element withinn @data_arr
p “First Element in @data_arr: #partitoned_arraypartitoned_array.get(id)” # gets an entry from @data_arr directly
puts</p>

<h1 id="set-an-element-within-dataarr-ignores-partitions-and-goes-for-raw-ids">Set an element within @data_arr; ignores partitions and goes for raw ids</h1>

<p>partitioned_array.set(id) do |hash|
   hash[“first”] = “1st” <br />
end</p>

<p>partitioned_array.set(id + 1) do |hash|
    hash[“second”] = “2nd”
end</p>

<h1 id="add-a-partition-to-the-rangearr-dataarr-add-partitionamountandoffset-to-relarr-dbsize-increases-by-one">add a partition to the @range_arr; @data_arr, add partition_amount_andoffset to @rel_arr, @db_size increases by one</h1>
<p>partitioned_array.add_partition 
partitioned_array.add_partition</p>

<p>allocate_ranges_sequentially(partitioned_array)</p>

<p>partitioned_array.add_partition</p>

<p>last_element = -1
partitioned_array.set(last_element) do |hash|
    hash[“last”] = “Nth”
end</p>

<h1 id="all-that-has-to-be-done-to-store-the-partitionedarray-instance-data">All that has to be done to store the PartitionedArray instance data</h1>
<p>=begin
PartitionedArray#load_from_json!()
PartitionedArray#dump_to_json!
PartitionedArray#save_partition_to_file!
PartitionedArray#load_partition_from_file!
=end</p>

<h1 id="test-to-see-if-file-loading-and-unloading-creates-equivalent-data-structures">Test to see if file loading and unloading creates equivalent data structures</h1>
<p>puts “Before:”</p>

<p>p partitioned_array.data_arr
p partitioned_array.partition_amount_and_offset
p partitioned_array.range_arr
p partitioned_array.rel_arr</p>

<p>_data_arr = partitoned_array.data_arr
_partition_amount_and_offset = partitioned_array.partition_amount_and_offset
_range_arr = partitioned_array.range_arr
_rel_arr = y.rel_arr</p>

<p>partitioned_array.dump_to_json!
partitioned_array.load_from_json!</p>

<h1 id="assert-tests">assert tests</h1>
<p>p “@data_arr remains the same: #== _data_arr”
p “@partition_amount_and_offset: #== _partition_amount_and_offset”
p “@range_arr: #== _range_arr”
p “@rel_arr: #== _rel_arr”</p>

<p>p “Get a certain slice of @data_arr (0..4): #partitiond_array.data_arr[0.partitiond_array.data_arr[0..4]”
p “Load partition data into @data_arr (0th): #partitioned_arraypartitioned_array.load_partition_from_file!(0)”</p>

<p>partitioned_array.save_partition_to_file!(0)</p>

<h1 id="partitionedarraysetpartitionsubelementid-partitionid-block">PartitionedArray#set_partition_subelement(id, partition_id, &amp;block)</h1>
<p>success = partitioned_array.set_partition_subelement(0, 0) do |hash|
    hash[:modified] = “0, 0”
end
p “successfully modified partition subelement: #success”
p “New @data_arr: #@data_arr”</p>

<p><code>
Output
</code>ruby
“First Partition in @data_arr: [{}, {}, {}, {}, {}, {}, {}]”
“First Element in @data_arr: {}”</p>

<p>Before:
[“id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, {}, {}, {}, {}, {}, “last”=&gt;”Nth”]
6
[0..6, 7..12, 13..18, 19..24, 25..30, 31..36]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24, 24, 25, 26, 27, 28, 29, 30, 30, 31, 32, 33, 34, 35, 36]
“@data_arr remains the same: true”
“@partition_amount_and_offset: true”
“@range_arr: true”
“@rel_arr: true”
“Get a certain slice of @data_arr (0..4): [“id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0]”
“Load partition data into @data_arr (0th): [“id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0]”
“successfully modified partition subelement: true”
“New @data_arr: [“id”=&gt;0, :modified=&gt;”0, 0”, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;0, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;1, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;2, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;3, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, “id”=&gt;4, {}, {}, {}, {}, {}, “last”=&gt;”Nth”]”
```</p>

<h2 id="managed-partitioned-array-data-structure">Managed Partitioned Array Data Structure</h2>

<h3 id="synopsis---partitionedarraymanagedpartitionarray">Synopsis - PartitionedArray/ManagedPartitionArray</h3>

<p>This will talk about the Partitioned Array and its suggested counterpart superset, the<code>ManagedPartitionedArray (lib/managed_partitioned_array.rb)</code></p>

<h4 id="managedpartitionedarray">ManagedPartitionedArray</h4>

<p>(Last updated: 10/19/2022 12:11PM)</p>

<h4 id="instance-methods">Instance Methods</h4>

<p>```ruby
mpa = mpa.archive_and_new_db!</p>

<p>mpa.load_archive_no_auto_allocate!</p>

<p>mpa = mpa.load_from_archive!(partition_archive_id: @max_partition_archive_id)</p>

<p>mpa.at_capacity? # Depends on the MPA variables</p>

<p>mpa.add(return_added_element_id: true, &amp;block)</p>

<p>mpa.get(id, hash: false) #see PartitionedArray</p>

<p>mpa.load_everything_from_files! # in PA class, its load_all_from_files!</p>

<p>mpa.save_everything_to_files!</p>

<p>mpa.increment_max_partition_archive_id!
```</p>

<h4 id="finite-length-arrays">Finite Length arrays</h4>

<p>```ruby</p>

<p>mpa = ManagedPartitionedArray(max_capacity: “data_arr_size” || Integer, dynamically_allocates: false)
```</p>

<p>Capable of jumping to a new file partition
### Never ending array adds</p>

<p>```ruby</p>

<p>mpa = ManagedPartitionedArray.new(endless_add: true, has_capacity: false, dynamically_allocates: true)<code>
</code>``</p>

<h4 id="dynamic-allocation">Dynamic Allocation</h4>

<p>```ruby</p>

<p>mpa = ManagedPartitionedArray.new(dynamically_allocates: true)
```</p>

<h4 id="array-split-by-file-partitions">Array split by file partitions</h4>

<p><code>ruby
 mpa = ManagedPartitionedArray.new(max_capacity: "data_arr_size",   db_size: DB_SIZE,   partition_amount_and_offset: PARTITION_AMOUNT + OFFSET,   db_path: "./db/sl",   db_name: 'sl_slice')
</code></p>

<p>Where <code>max_capacity</code> could be the max <code>@data_arr</code> size, or a defined integer</p>

<p>Check if <code>mpa.at_capacity?</code> to figure out if the MPA is at capacity</p>

<h4 id="switching-and-allocating-to-a-new-file-partition">Switching and allocating to a new file partition</h4>

<p><code>ruby
mpa = ManagedPartitionedArray.new(max_capacity: "data_arr_size",   db_size: DB_SIZE,   partition_amount_and_offset: PARTITION_AMOUNT + OFFSET,   db_path: "./db/sl",   db_name: 'sl_slice')
mpa = mpa.archive_and_new_db!
mpa.save_everything_to_files!
</code></p>

<p>It implements the Value Object pattern; the other archive is closed and saved and the partitioned array starts out in a new partition that mirrors the others if max_capacity = “data_arr_size”</p>

<p>“data_arr_size” is sure to fill the entire array before throwing  at_capacity? is true.</p>

<h4 id="file-context-managed-partitioned-array-definition">File Context Managed Partitioned Array (Definition)</h4>

<p>We have: <code>file_context_array["file_db_name_string"].managed_partitioned_array[mpa_db_file_id_integer].partitioned_array(db_id, id)</code></p>

<p>let <code>PA (partitioned array) = P</code></p>

<p>let <code>MPA = a = Q &lt; P</code></p>

<p>let <code>FCA = f = b&lt;a ~= b.a</code></p>

<p><code>f</code> expands to <code>f.(Q &lt; P)</code> =&gt; <code>f.(b &lt; a)</code> =~&gt; <code>f.(b.a)</code></p>

<p>and,</p>

<p>we have in this context:</p>

<p><code>file_context_array["file_db_name_string"].managed_partitioned_array[mpa_db_file_id_integer].partitioned_array(db_id, id)</code></p>

<p>Could also be written as: <code>file_context_array["file_db_name_string"].(managed_partitioned_array[mpa_db_file_id_integer] &lt; partitioned_array(db_id, id))</code></p>

<p>Methods:</p>

<ul>
  <li>VERSION v1.0.2a - Prettified, and listed all functions below</li>
</ul>

<p>```ruby
FCMPA#load_indexer_db! - loads the indexing DB</p>

<p>FCMPA#new_database! - creates a new database</p>

<p>FCMPA#start_database! - starts a database</p>

<p>FCMPA#delete_database_from_index! - deletes a database from the index</p>

<p>FCMPA#add_database_to_index! - adds a database to the index</p>

<p>FCMPA#db(database_index_name = @active_database) - returns the database</p>

<p>FCMPA#set_active_database(database_index_name) - sets the active database</p>

<p>FCMPA#stop_database!(database_index_name) - stops a database</p>

<p>FCMPA#stop_databases! - stops all databases</p>

<p>FCMPA#save_databases! - saves all databases</p>

<p>FCMPA#load_database!(database_index_name = @active_database) - loads a database</p>

<p>FCMPA#load_databases! - loads all databases</p>

<p>FCMPA#delete_database!(database_index_name = @active_database) - deletes a database</p>

<p>FCMPA#get_databases_list - returns a list of databases</p>

<p>FCMPA#set_new_file_archive!(database_index_name = @active_database) - sets a new file archive for a database</p>

<p>FCMPA#each(database_index_name, hash: @traverse_hash) - traverses a database</p>

<p>FCMPA#each_not_nil(database_index_name, hash: @traverse_hash) - traverses a database, skipping nil values
```</p>

<h4 id="file-context-managed-partitioned-array-manager-definition">File Context Managed Partitioned Array <em>Manager</em> (Definition)</h4>
<p>The database manager is the <code>FCMPAM</code> class. It is a singleton class that manages the <code>FCMPA</code> class. The <code>FCMPA</code> class manages the <code>MPA</code> class. The <code>MPA</code> class manages the <code>PA</code> class.</p>

<p>FCMPAM.FCMPA.MPA.PA or FCMPAM.FCMPA.(MPA &lt; PA)</p>

<h2 id="defined-methods-fcmpam--file-context-managed-partitioned-array-manager--filecontextmanagedpartitionedarraymanagerrb">Defined Methods (FCMPAM = File Context Managed Partitioned Array Manager = file_context_managed_partitioned_array_manager.rb)</h2>

<p>```ruby
FCMPAM#database(database_name = @active_database): returns the database object</p>

<p>FCMPAM#database_table(database_name: @active_database, database_table: @active_table): returns the database table object</p>

<p>FCMPAM#new_database!(database_name): creates a new database</p>

<p>FCMPAM#new_table!(database_name:, database_table:): creates a new table in the database</p>

<p>FCMPAM#active_database(database_name): sets the active database</p>

<p>FCMPAM#active_table(database_table): sets the active table</p>

<p>FCMPAM#table(database_table = @active_table): returns the active table</p>

<p>FCMPAM#database(database_name = @active_database): returns the active database
```</p>

<h2 id="generate-documentation">Generate Documentation</h2>

<p><code>gem install yard</code></p>

<h2 id="in-directory">In Directory:</h2>

<p><code>yard doc</code></p>
</div></div>

      <div id="footer">
  Generated on Fri Jan 27 04:56:48 2023 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.28 (ruby-3.2.0).
</div>

    </div>
  </body>
</html>